# -*- coding: utf-8 -*-
"""proyecto: BdSeIF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ULhgCLzb6t3ElUJEQ2PnCnHTYTkuBxkQ

# $\color{Teal}{\huge\text{En búsqueda de parámetros :)}}$
$\color{Teal}{\huge\text{Reconstrucción del Espacio Fase del Sistema Rössler usando Algoritmos Genéticos}}$ \\

$\color{pink}{\text{Proyecto: Búsqueda de Soluciones e Inferencia Bayesiana.}}$ \\
$\color{pink}{\text{Valeria Svetlhana Gutiérrez López}}$ \\
$\color{pink}{\text{Dr. Jorge Hermosillo Valadez}}$ \\
$\color{pink}{\text{Licenciatura en Inteligencia Artificial}}$
"""

#@title Librerias :)

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from sklearn.neighbors import NearestNeighbors
import random

#@title generar sistema rössler :)
def rossler(t, state, a=0.2, b=0.2, c=5.7):
    x, y, z = state
    dxdt = -y - z
    dydt = x + a*y
    dzdt = b + z*(x - c)
    return [dxdt, dydt, dzdt]

#simulación del sistema Rössler
t_span = (0, 100) #define el intervalo del tiempo de la simulación
t_eval = np.linspace(0, 100, 10000)  #especifica puntos donde queremos evaluar las soluciones
y0 = [1, 1, 1] #estado inicial en x, y, z
sol = solve_ivp(rossler, t_span, y0, t_eval=t_eval)
#print(sol)
#extraemos la serie x(t)
x_t = sol.y[0]
print(x_t)

#@title grafica de Rössler
def plot_rossler(sol):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.plot(sol.y[0], sol.y[1], sol.y[2], lw=0.5)
    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")
    ax.set_title("Sistema Rössler")
    plt.show()

plot_rossler(sol)

#@title grafica de la serie x(t)
def plot_series(x, t):
    plt.figure()
    plt.plot(t, x, label="X(t)", color="orchid")
    plt.xlabel("Tiempo")
    plt.ylabel("X(t)")
    plt.title("Serie Temporal X(t)")
    plt.legend()
    plt.show()

plot_series(x_t, t_eval)

#@title definit tau

def optimal_tau(x):
    autocorr = np.correlate(x, x, mode='full')
    autocorr = autocorr[autocorr.size // 2:] #ls mitad positiva pq esto representa los retardos hacia adelante
    return np.argmax(autocorr < 0.5 * autocorr[0])  # Primer cruce por debajo del 50%

tau = optimal_tau(x_t)
print(f"Valor óptimo de tau: {tau}")

#@title grafica de autocorrelación

def plot_autocorrelation(x):
    autocorr = np.correlate(x, x, mode='full')
    autocorr = autocorr[autocorr.size // 2:]
    plt.figure()
    plt.plot(autocorr, label="Autocorrelación", color="orchid")
    plt.xlabel("Desplazamiento")
    plt.ylabel("Autocorrelación")
    plt.title("Autocorrelación de X(t)")
    plt.legend()
    plt.show()

plot_autocorrelation(x_t)

#@title reconstruccion del atractor :)

def phase_space_reconstruction(x, m, tau):
    N = len(x) - (m - 1) * tau #numero de puntos disponibles para la reconstruccion
    return np.array([x[i:N + i] for i in range(0, m * tau, tau)]).T  #arreglo deonde cada fila es una trayectoria

#vecinos falsos
def false_nearest_neighbors(X, r=10):
    nbrs = NearestNeighbors(n_neighbors=2).fit(X)
    distances, indices = nbrs.kneighbors(X)
    d_m = distances[:, 1]  # Distancia al primer vecino
    d_m1 = np.sqrt(d_m**2 + (X[:, -1] - X[indices[:, 1], -1])**2)  # Dimensión aumentada
    return np.sum(d_m1 / d_m > r) / len(X)  # Fracción de vecinos falsos

#@title AG -.-
def genetic_algorithm(x, tau, generations=10, population_size=10):
    population = np.random.randint(2, 5, population_size)  # Reducimos el rango a 2-4
    for gen in range(generations):
        fitness = [false_nearest_neighbors(phase_space_reconstruction(x, m, tau)) for m in population]
        best_indices = np.argsort(fitness)[:population_size // 2]  # Selección de mejores
        parents = population[best_indices]
        offspring = [max(2, min(4, random.choice(parents) + random.randint(-1, 1))) for _ in range(population_size // 2)]
        population = np.concatenate((parents, offspring))  # Mutación y cruce
    best_m = population[np.argmin(fitness)]
    return best_m

m_optimal = genetic_algorithm(x_t, tau)
print(f"Dimensión óptima encontrada por AG: {m_optimal}")

#@title reconstruccion con el m encontrado :)
X_emb = phase_space_reconstruction(x_t, m=m_optimal, tau=tau)
fnn = false_nearest_neighbors(X_emb)
print(f"Fracción de vecinos falsos con m óptimo: {fnn:.4f}")

#@title grafica de la reconstruccion con AG
def plot_reconstructed_attractor(X):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')# ag/V
    ax.plot(X[:, 0], X[:, 1], X[:, 2], lw=0.5)
    ax.set_xlabel("X(t)")
    ax.set_ylabel("X(t-τ)")
    ax.set_zlabel("X(t-2τ)")
    ax.set_title("Atractor reconstruido con m óptimo")
    plt.show()

plot_reconstructed_attractor(X_emb)